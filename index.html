<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Linked-lifted : New user interfaces for interconnection modules" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Linked-lifted</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/ThibWeb/linked-lifted">View on GitHub</a>

          <h1 id="project_title">Linked-lifted</h1>
          <h2 id="project_tagline">New user interfaces for interconnection modules</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/ThibWeb/linked-lifted/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/ThibWeb/linked-lifted/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Module development for Datalift</h1>

<ul>
<li><a href="https://gist.github.com/2989006">Fast-paced build script as a Gist</a></li>
<li><a href="https://delicious.com/stacks/view/EqgnIa">UI inspiration stack on Delicious</a></li>
</ul><h2>Datalift architecture</h2>

<p>The <a href="http://datalift.org/">Datalift</a> publishing platform is developed on a large technology stack.</p>

<p><strong>Server-side :</strong></p>

<ul>
<li>JEE 5</li>
<li>Jersey 1.9</li>
<li>Shiro 1.1.0</li>
<li>Velocity 1.7</li>
<li>Sesame 2.6</li>
<li>Empire 0.7</li>
<li>Log4j 1.2.16</li>
<li>OpenCSV 2.3</li>
<li>Wro4j 1.4.1</li>
</ul><p><strong>Client-side :</strong></p>

<ul>
<li>Velocity 1.7</li>
<li>HTML</li>
<li>CSS</li>
<li>Javascript</li>
<li>jQuery 1.5.2</li>
<li>jQuery UI 1.8.9</li>
<li>jQuery grid 4.0.0</li>
</ul><p>The Velocity Engine uses the Velocity Template Language (VTL), but web pages can also be made entirely out of static HTML.</p>

<h2>Overview of the development workflow</h2>

<p>Datalift can be deployed in two ways :</p>

<ul>
<li>During development, inside an application server like Tomcat.</li>
<li>In a production environment, as a native stand-alone application.</li>
</ul><p>Here we'll look at how to automate our development workflow divided into three steps : </p>

<ol>
<li>Module source code compilation.</li>
<li>Jar deployment inside the Datalift home.</li>
<li>Refreshing our modifications.</li>
</ol><h3>Compilation with Ant</h3>

<p>Datalift and its modules must be compiled using the <a href="https://ant.apache.org/">Ant</a> Java building tool. The Datalift architecture and each of its modules have their own Ant build file which will create one JAR per module according to its own rules.
For a given module, the command to compile its sources and retrieve its JAR is <code>ant dist</code> : call to the dist target of our build.xml file.</p>

<p>We can call it from our own script using :</p>

<pre><code>&lt;target name="compile"&gt;
    &lt;subant target="dist"&gt;
        &lt;filelist dir="${project.code}" files="${module.name}"/&gt;
    &lt;/subant&gt;
&lt;/target&gt;
</code></pre>

<h3>Deployment within Tomcat</h3>

<p>Once the JAR is created, it must be placed inside the "modules" directory of the Datalift installation directory. In a development environment, its path is <code>../datalift-home/modules</code>.
It is unneccesary to redeploy the WAR nor the whole datalift-home at every modification to our module.</p>

<pre><code>&lt;target name="deploy" depends="compile, transfer"/&gt;


&lt;target name="transfer"&gt;
    &lt;copy file="${module.jar}" todir="${project.modules}" overwrite="true"/&gt;
&lt;/target&gt;
</code></pre>

<p><strong>/!\</strong> If our modifications only affect static HTML code, the JAR transfer will suffice to update our HTML rendering. Otherwise, we'll also have to reload Tomcat.</p>

<pre><code>&lt;target name="reload" depends="stop, deploy, start"/&gt;

&lt;target name="stop"&gt;
    &lt;java jar="${tomcat.bootstrap}" fork="true" spawn="true"&gt;
        &lt;jvmarg value="-Dcatalina.home=${tomcat.home}"/&gt;
        &lt;arg line="stop"/&gt;
    &lt;/java&gt;
    &lt;waitfor maxwait="3000" checkevery="1000"&gt;
        &lt;not&gt;
            &lt;socket server="${tomcat.server}" port="${tomcat.port}"/&gt;
        &lt;/not&gt;
    &lt;/waitfor&gt;
    &lt;exec executable="say" spawn="yes"&gt;
    &lt;arg line="${tomcat.msg.stop}"/&gt;
&lt;/exec&gt;
&lt;exec executable="growlnotify" spawn="yes"&gt;
    &lt;arg line="growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.stop}'"/&gt;
&lt;/exec&gt;
&lt;/target&gt;
</code></pre>

<p>We wait for Tomcat not to answer anymore to judge it stopped. We use <code>say</code> and <code>growlnotify</code> to make our lives easier.</p>

<pre><code>&lt;target name="start"&gt;
    &lt;java jar="${tomcat.bootstrap}" fork="true" spawn="true"&gt;
        &lt;jvmarg value="-Dcatalina.home=${tomcat.home}"/&gt;
        &lt;jvmarg value="-Ddatalift.home=${project.home}"/&gt;
    &lt;/java&gt;
    &lt;waitfor maxwait="10000" checkevery="1000"&gt;
        &lt;http url="${module.url}"/&gt;
    &lt;/waitfor&gt;
    &lt;exec executable="say" spawn="yes"&gt;
    &lt;arg line="${tomcat.msg.start}"/&gt;
&lt;/exec&gt;
&lt;exec executable="growlnotify" spawn="yes"&gt;
    &lt;arg line="growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.start}'"/&gt;
&lt;/exec&gt;
&lt;/target&gt;
</code></pre>

<p>The <code>datalift.home</code> argument is used to target the datalift-home directory where our modules and configuration files are. We wait for our module's URL to be retrieved to let the start process pass.</p>

<h3>Results refreshing</h3>

<p>To maximize automation, we don't want to have to manually refresh our HTML rendering. In order to do so, we can use the <code>ant open</code> command which will automatically open the module URL into our default browser. With this method we'll still have to go to the command line.</p>

<pre><code>&lt;target name="open"&gt;
    &lt;exec executable="open" spawn="yes"&gt;
        &lt;arg line="${module.url}"/&gt;
    &lt;/exec&gt;
&lt;/target&gt;
</code></pre>

<p>To not have to use the command line, we use <a href="http://livereload.com/">LiveReload</a>. LiveReload monitors our module's source code and automatically triggers browser refresh each time a modification is detected. LiveReload also allows to preceed each refresh by a script execution, thus we're going to use it to fully automate our workflow :</p>

<ul>
<li>At any modification inside the <code>web</code> directory, LiveReload will execute <code>ant -buildfile live-build.xml deploy</code>, which will update the JAR file.</li>
<li>At any modification inside the <code>java</code> directory, which requires Tomcat to be reloaded, we'll launch <code>ant -buildfile ../../live-build.xml reload</code>.</li>
</ul><p>All that's left to do is tell LiveReload to focus on .vm, .java and .properties files and the update process will be triggered at each file save.</p>

<p>Our development cycle can be further optimized by hosting our .css and .js files outside of our module : they'll be hosted on another local HTTP server : they are stored in /modulepath/src/web/public and made available with <code>open http://localhost:8000 &amp;&amp; python -m SimpleHTTPServer</code>. LiveReload can be told to monitor the public folder and to automatically refresh the browser, without needing to redeploy our JAR.</p>

<h2>StringToURI integration</h2>

<p>As a linked data publishing platform, Datalift needs dataset interconnection modules. <a href="http://stringtouri.assembla.me">StringToURI</a> is a little tool which replaces strings inside a dataset by URIs to another dataset's entities according to different criteria. It'll be integrated into Datalift as a starter project to be done before bigger module interface developments.</p>

<h3>Interface</h3>

<p>Here's our final mockup :</p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/mockup.png" alt="Mockup of the StringToURI module interface"></p>

<p>We use a simple two columns layout. While it makes the path to completion harder to understand, it makes it easier to distinguish between the two groups of inputs : one for the dataset we're working on, and one for the one we'll link to.
Each field is surrounded by a label and a much longer description, where the field maybe mentionned as required. Fields' placeholders also tell whether the fields are required, and color code helps distinction between correct values and errors / empty fields. The textfield's width depends on the window's width with a breakpoint at 350px, which is the minimum width.</p>

<p>Here's the final result :</p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/parameters.png" alt="The final StringToURI module interface"></p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/states.png" alt="Success and error states"></p>

<p>The two groups are much more separated (using fieldsets), a cancel button has ben added as a <a href="http://www.lukew.com/ff/entry.asp?571">secondary action</a>, and all select inputs have been replaced with text fields with autocompletion to allow faster input and copy and paste.</p>

<p>While this result may not be as eye candy as the mockup, it makes use of the Datalift default theme while introducing new elements such as top-label inputs. (<a href="http://www.lukew.com/ff/entry.asp?504">Here is why.</a>)</p>

<p>Non-default Datalift CSS :</p>

<pre><code>    .form-stack {
    display:block;
    margin:10px 0 0;
    padding:10px;
}

.form-stack label {
    font-weight:bold;   
    margin-bottom:3px;
    display:block;
}

.form-stack input[type=text] {
    width:350px;
}

.form-stack p {
    margin:2px 0;
    color:#666;
    font-size:75%;
}

.form-stack .ui-icon {
    float:left;
    margin-right: 5px;
    display:none;
}
</code></pre>

<p>Everything is built to keep the overall Datalift look and feel while improving usability, accessibility (visual cues with colors and icons, textual cues as well) and completion time. We want to keep using the default CSS and jQuery UI theme as much as possible. We want our layout to adapt itself to the available screen real estate :</p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/small.png" alt="A small screen size"></p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/large.png" alt="A view for larger screens"></p>

<p>Regarding behavior, our module makes use of jQuery and of its multiple capabilities. We use it to change the look of our fields according to their state of completion :</p>

<pre><code>function errorState(field) {
    field.removeClass("ui-state-success");
    field.parent().addClass("ui-state-error");
    field.next("p").contents().first()
        .removeClass("ui-icon-help ui-icon-check")
        .addClass("ui-icon-alert")
        .show();
}
</code></pre>

<p>We also use its autocompletion widget and its event handler API : </p>

<pre><code>ourpredicate.autocomplete({source: ourpredicates, minLength: 0, delay: 300});
ourpredicate.blur(function() {validateMandatory(ourpredicate, ourpredicates);});
theirpredicate.autocomplete({source: theirpredicates, minLength: 0, delay: 300});
theirpredicate.blur(function() {validateMandatory(theirpredicate, theirpredicates);});

$("#linkage-form").submit(function(){return validateAll();});
</code></pre>

<p>The web page's HTML / structure is made with <a href="https://velocity.apache.org/">Velocity</a>, which syntaxe looks like this :</p>

<pre><code>&lt;h3 class="ui-widget-header dl-widget-header"&gt;
    #if ($current == $english) 
        ${it.title} #i18n('project.label') 
    #else 
        #i18n('project.label') ${it.title} 
    #end 
    &amp;mdash; #i18n('stringtouri.title')
&lt;/h3&gt;
</code></pre>

<p>Here we use it to display our title in a different order whether the current language is english or french. <code>#i18n</code>manages content internationalization while ${var} is used to access variables defined inside our Java code.</p>

<p>Here is an english version :</p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/english.png" alt="StringToURI's interface in english"></p>

<p>Velocity can manage complex object types like lists : </p>

<pre><code>var datasets = [
    #foreach( $source in $sources )
    "$source",
    #end
];
</code></pre>

<p>StringToURI has two other views which are served after the interconnection process. The results view makes use of Datalift's conventions to display the newly created links in a searchable / sortable array.</p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/results.png" alt="New links are displayed in an array"></p>

<p>Velocity can handle complex data types like lists of lists :</p>

<pre><code>## For each new triple, we'll display its S, P, O.
#foreach( $triple in $newtriples )
    #if( $foreach.count &gt; $maxEntries ) 
        #break 
    #end
    ## Line number may be useful.
    &lt;tr&gt;&lt;td&gt;$velocityCount&lt;/td&gt;
    #foreach( $elt in $triple ) 
        &lt;td title="$!esc.html($elt)"&gt;$!esc.html($elt)&lt;/td&gt; 
    #end
    &lt;/tr&gt;
#end
</code></pre>

<p>The other view displays errors, if any. As parameters are checked in Javascript, it may not seem important to check them again on the server-side, but indeed it is if Javascript isn't allowed or if StringToURI is launched from a remote module (via GET parameters). </p>

<p><img src="https://github.com/ThibWeb/linked-lifted/raw/gh-pages/errors.png" alt="Errors in the parameters"></p>

<h3>Back-end</h3>

<p>To serve our interfaces with their Velocity template language, we have to manage them with Java classes.
We use Jax-RS / <a href="http://jersey.java.net/">Jersey</a> annotations to indicate our web architecture to the Datalift Core : </p>

<pre><code>@Path(StringToURI.MODULE_NAME)


public class InterconnectionController extends BaseModule implements ProjectModule {
...
}
</code></pre>

<p>We must indicate which kind of project our module can handle to our ProjectManager :</p>

<pre><code>public UriDesc canHandle(Project p) {
    // The project can be handled if it has at least two RDF sources.
    if (hasMultipleRDFSources(p.getSources(), 2)) {
        // Here the URL and label to our object in ProjectManager
        UriDesc uridesc = new UriDesc(this.getName() + "?project=" + p.getUri(),this.label);
    }       
    return uridesc;
}
</code></pre>

<p>We then use annotations to indicate what to serve when asking for the module's index page : Here, we are using GET, producing HTML and one of the query parameters is our current project's URI.<br>
We access Datalift's internal repository to make its data available to our Velocity template by using the <code>args</code> HashMap : <code>args.put("sources", sourcesURIs);</code>to autocomplete source fields.</p>

<pre><code>@GET
@Produces(MediaType.TEXT_HTML)
public Response getIndexPage(@QueryParam("project") URI projectId) throws ObjectStreamException {
    // Retrieve the current project and its sources.
    Project proj = this.getProject(projectId);
    LinkedList&lt;String&gt; sourcesURIs = model.getSourcesURIs(proj);

    HashMap&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();

    args.put("sources", sourcesURIs);
    args.put("classes", model.getAllClasses(sourcesURIs));
    args.put("predicates", model.getAllPredicates(sourcesURIs));

    return Response.ok(this.newViewable("/stringtouri-form.vm", args)).build();
}
</code></pre>

<p>Two other methods are used to handle the execution :</p>

<pre><code>@POST
@Produces(MediaType.TEXT_HTML)
public Response doSubmit(...) { ... }

@GET
@Path("go")
@Produces(MediaType.TEXT_HTML)
public Response doRemoteSubmit(...) { return doSubmit(...); }
</code></pre>

<p>They both end up delegating the launch and parameters validation to our application's model. It's the model which manages queries to the repositories and back-end logic, like logging important events such as the StringToURI process launch :</p>

<pre><code>if (validateAll(...)) {
    // Launches a new StringToURI process.
    SesameApp stu = new SesameApp(INTERNAL_URL, INTERNAL_URL, sourceContext, targetContext);

    if (sourceClass.isEmpty() || targetClass.isEmpty()) {
        stu.useSimpleLinkage(sourcePredicate, targetPredicate);
    }
    else {
        stu.useTypedLinkage(sourcePredicate, targetPredicate, sourceClass, targetClass);
    }

    stu.useSPARQLOutput(false);
    ret = stu.getOutputAsList();

    if (LOG.isInfoEnabled()) {
        LOG.info(MODULE_NAME + " interconnection OK.");
    }
</code></pre>

<p>Or such as queries sent to the repository :</p>

<pre><code>if (LOG.isDebugEnabled()) {
    LOG.debug(MODULE_NAME + " " + query);
}

try {
    tq = internal.prepareTupleQuery(QueryLanguage.SPARQL, query);
    tqr = tq.evaluate();

    if (!hasCorrectBindingNames(tqr, bind)) {
        throw new MalformedQueryException("Wrong query bindings - " + query);
    }

    while (tqr.hasNext()) {
        ret.add(tqr.next().getValue(bind).stringValue());
    }
}
</code></pre>

<h3>StringToURI's next improvements</h3>

<p>In the near future, it would be nice to revamp the StringToURI's interface to be even more responsive to different screen sizes while keeping it simple and error-proof. </p>

<p>Here are some interesting features to develop :</p>

<ul>
<li>Better design to maximize screen efficiency.</li>
<li>AJAX calls to refresh autocomplete values while typing.</li>
<li>AJAX calls to validate user input, thus keeping all of the validation logic on the server side.</li>
<li>New intermediate state which allows to visualize new triples before validating the update.</li>
<li>New ways to call the process from other modules / to pre-fill the form.</li>
</ul><h2>Dataset Browser integration</h2>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Linked-lifted maintained by <a href="https://github.com/ThibWeb">ThibWeb</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
