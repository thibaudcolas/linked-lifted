{"tagline":"New user interfaces for interconnection modules","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Linked-lifted","body":"# Module development for Datalift\r\n\r\n- [Fast-paced build script as a Gist](https://gist.github.com/2989006)\r\n- [UI inspiration stack on Delicious](https://delicious.com/stacks/view/EqgnIa)\r\n\r\n## Datalift architecture\r\n\r\nThe [Datalift](http://datalift.org/) publishing platform is developed on a large technology stack.\r\n\r\n__Server-side :__\r\n\r\n- JEE 5\r\n- Jersey 1.9\r\n- Shiro 1.1.0\r\n- Velocity 1.7\r\n- Sesame 2.6\r\n- Empire 0.7\r\n- Log4j 1.2.16\r\n- OpenCSV 2.3\r\n- Wro4j 1.4.1\r\n\r\n__Client-side :__\r\n\r\n- Velocity 1.7\r\n- HTML\r\n- CSS\r\n- Javascript\r\n- jQuery 1.5.2\r\n- jQuery UI 1.8.9\r\n- jQuery grid 4.0.0\r\n\r\nThe Velocity Engine uses the Velocity Template Language (VTL), but web pages can also be made entirely out of static HTML.\r\n\r\n## Overview of the development workflow\r\n\r\nDatalift can be deployed in two ways :\r\n\r\n* During development, inside an application server like Tomcat.\r\n* In a production environment, as a native stand-alone application.\r\n\r\nHere we'll look at how to automate our development workflow divided into three steps : \r\n\r\n1. Module source code compilation.\r\n2. Jar deployment inside the Datalift home.\r\n3. Refreshing our modifications.\r\n\r\n### Compilation with Ant\r\n\r\nDatalift and its modules must be compiled using the [Ant](https://ant.apache.org/) Java building tool. The Datalift architecture and each of its modules have their own Ant build file which will create one JAR per module according to its own rules.\r\nFor a given module, the command to compile its sources and retrieve its JAR is `ant dist` : call to the dist target of our build.xml file.\r\n\r\nWe can call it from our own script using :\r\n\r\n    <target name=\"compile\">\r\n        <subant target=\"dist\">\r\n            <filelist dir=\"${project.code}\" files=\"${module.name}\"/>\r\n        </subant>\r\n    </target>\r\n\r\n### Deployment within Tomcat\r\n\r\nOnce the JAR is created, it must be placed inside the \"modules\" directory of the Datalift installation directory. In a development environment, its path is `../datalift-home/modules`.\r\nIt is unneccesary to redeploy the WAR nor the whole datalift-home at every modification to our module.\r\n\r\n    <target name=\"deploy\" depends=\"compile, transfer\"/>\r\n\r\n\r\n    <target name=\"transfer\">\r\n        <copy file=\"${module.jar}\" todir=\"${project.modules}\" overwrite=\"true\"/>\r\n    </target>\r\n\r\n__/!\\\\__ If our modifications only affect static HTML code, the JAR transfer will suffice to update our HTML rendering. Otherwise, we'll also have to reload Tomcat.\r\n\r\n    <target name=\"reload\" depends=\"stop, deploy, start\"/>\r\n\r\n    <target name=\"stop\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <arg line=\"stop\"/>\r\n        </java>\r\n        <waitfor maxwait=\"3000\" checkevery=\"1000\">\r\n            <not>\r\n                <socket server=\"${tomcat.server}\" port=\"${tomcat.port}\"/>\r\n            </not>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.stop}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.stop}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nWe wait for Tomcat not to answer anymore to judge it stopped. We use `say` and `growlnotify` to make our lives easier.\r\n\r\n    <target name=\"start\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <jvmarg value=\"-Ddatalift.home=${project.home}\"/>\r\n        </java>\r\n        <waitfor maxwait=\"10000\" checkevery=\"1000\">\r\n            <http url=\"${module.url}\"/>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.start}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.start}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nThe `datalift.home` argument is used to target the datalift-home directory where our modules and configuration files are. We wait for our module's URL to be retrieved to let the start process pass.\r\n\r\n### Results refreshing\r\n\r\nTo maximize automation, we don't want to have to manually refresh our HTML rendering. In order to do so, we can use the `ant open` command which will automatically open the module URL into our default browser. With this method we'll still have to go to the command line.\r\n\r\n    <target name=\"open\">\r\n        <exec executable=\"open\" spawn=\"yes\">\r\n            <arg line=\"${module.url}\"/>\r\n        </exec>\r\n    </target>\r\n\r\nTo not have to use the command line, we use [LiveReload](http://livereload.com/). LiveReload monitors our module's source code and automatically triggers browser refresh each time a modification is detected. LiveReload also allows to preceed each refresh by a script execution, thus we're going to use it to fully automate our workflow :\r\n \r\n* At any modification inside the `web` directory, LiveReload will execute `ant -buildfile live-build.xml deploy`, which will update the JAR file.\r\n* At any modification inside the `java` directory, which requires Tomcat to be reloaded, we'll launch `ant -buildfile ../../live-build.xml reload`.\r\n\r\nAll that's left to do is tell LiveReload to focus on .vm, .java and .properties files and the update process will be triggered at each file save.\r\n\r\nOur development cycle can be further optimized by hosting our .css and .js files outside of our module : they'll be hosted on another local HTTP server : they are stored in /modulepath/src/web/public and made available with `open http://localhost:8000 && python -m SimpleHTTPServer`. LiveReload can be told to monitor the public folder and to automatically refresh the browser, without needing to redeploy our JAR.\r\n\r\n## StringToURI integration\r\n\r\nAs a linked data publishing platform, Datalift needs dataset interconnection modules. [StringToURI](http://stringtouri.assembla.me) is a little tool which replaces strings inside a dataset by URIs to another dataset's entities according to different criteria. It'll be integrated into Datalift as a starter project to be done before bigger module interface developments.\r\n\r\n### Interface\r\n\r\nHere's our final mockup :\r\n\r\n![Mockup of the StringToURI module interface](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/stringtouri-mockup.png)\r\n\r\nWe use a simple two columns layout. While it makes the path to completion harder to understand, it makes it easier to distinguish between the two groups of inputs : one for the dataset we're working on, and one for the one we'll link to.\r\nEach field is surrounded by a label and a much longer description, where the field maybe mentionned as required. Fields' placeholders also tell whether the fields are required, and color code helps distinction between correct values and errors / empty fields.\r\n\r\nHere's the final result :\r\n\r\n![The final StringToURI module interface](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/stringtouri-result.png)\r\n\r\nThe two groups are much more separated (using fieldsets), a cancel button has ben added as a [secondary action](http://www.lukew.com/ff/entry.asp?571), and all select inputs have been replaced with text fields with autocompletion to allow faster input and copy and paste.\r\n\r\nWhile this result may not be as eye candy as the mockup, it makes use of the Datalift default theme while introducing new elements such as top-label inputs. ([Here is why.](http://www.lukew.com/ff/entry.asp?504))\r\n\r\nNon-default Datalift CSS :\r\n\r\n        .form-stack {\r\n\t\tdisplay:block;\r\n\t\tmargin:10px 0 0;\r\n\t\tpadding:10px;\r\n\t}\r\n\r\n\t.form-stack label {\r\n\t\tfont-weight:bold;\t\r\n\t\tmargin-bottom:3px;\r\n\t\tdisplay:block;\r\n\t}\r\n\r\n\t.form-stack input[type=text] {\r\n\t\twidth:350px;\r\n\t}\r\n\r\n\t.form-stack p {\r\n\t\tmargin:2px 0;\r\n\t\tcolor:#666;\r\n\t\tfont-size:75%;\r\n\t}\r\n\r\n\t.form-stack .ui-icon {\r\n\t\tfloat:left;\r\n\t\tmargin-right: 5px;\r\n\t\tdisplay:none;\r\n\t}\r\n\r\nEverything is built to keep the overall Datalift look and feel while improving usability, accessibility (visual cues with colors and icons, textual cues as well) and completion time. We want to keep using the default CSS and jQuery UI theme as much as possible.\r\n\r\nRegarding behavior, our module makes use of jQuery and of its multiple capabilities. We use it to change the look of our fields according to their state of completion :\r\n\r\n\tfunction errorState(field) {\r\n\t\tfield.removeClass(\"ui-state-success\");\r\n\t\tfield.parent().addClass(\"ui-state-error\");\r\n\t\tfield.next(\"p\").contents().first()\r\n\t\t\t.removeClass(\"ui-icon-help ui-icon-check\")\r\n\t\t\t.addClass(\"ui-icon-alert\")\r\n\t\t\t.show();\r\n\t}\r\n\r\nWe also use its autocompletion widget and its event handler API : \r\n\r\n\tourpredicate.autocomplete({source: ourpredicates, minLength: 0, delay: 300});\r\n\tourpredicate.blur(function() {validateMandatory(ourpredicate, ourpredicates);});\r\n\ttheirpredicate.autocomplete({source: theirpredicates, minLength: 0, delay: 300});\r\n\ttheirpredicate.blur(function() {validateMandatory(theirpredicate, theirpredicates);});\r\n\t\r\n\t$(\"#linkage-form\").submit(function(){return validateAll();});\r\n\r\nThe web page's HTML / structure is made with [Velocity](https://velocity.apache.org/), which syntaxe looks like this :\r\n\r\n\t<h3 class=\"ui-widget-header dl-widget-header\">\r\n\t\t#if ($current == $english) \r\n\t\t\t${it.title} #i18n('project.label') \r\n\t\t#else \r\n\t\t\t#i18n('project.label') ${it.title} \r\n\t\t#end \r\n\t\t&mdash; #i18n('stringtouri.title')\r\n\t</h3>\r\n\r\nHere we use it to display our title in a different order whether the current language is english or french. `#i18n`manages content internationalization while ${var} is used to access variables defined inside our Java code.\r\n\r\nVelocity can manage complex object types like lists : \r\n\r\n\tvar datasets = [\r\n\t\t#foreach( $source in $sources )\r\n\t\t\"$source\",\r\n\t\t#end\r\n\t];\r\n\r\n### Back-end\r\n\r\nTo serve our interfaces with their Velocity template language, we have to manage them with Java classes.\r\nWe use Jax-RS / [Jersey](http://jersey.java.net/) annotations to indicate our web architecture to the Datalift Core : \r\n\r\n\t@Path(StringToURI.MODULE_NAME)\r\n\tpublic class StringToURI extends BaseModule implements ProjectModule {\r\n\t...\r\n\t}\r\n\r\nWe must indicate which kind of project our module can handle to our ProjectManager :\r\n\r\n    public UriDesc canHandle(Project p) {\r\n        // The project can be handled if it has at least two RDF sources.\r\n        if (hasMultipleRDFSources(p.getSources(), 2)) {\r\n            // Here the URL and label to our object in ProjectManager\r\n            UriDesc uridesc = new UriDesc(this.getName() + \"?project=\" + p.getUri(),this.label);\r\n        }       \r\n        return uridesc;\r\n    }\r\n\r\nWe then use annotations to indicate what to serve when asking for the module's index page : Here, we are using GET, producing HTML and one of the query parameters is our current project's URI.  \r\nWe access Datalift's internal repository to make its data available to our Velocity template by using the `args` HashMap : `args.put(\"sources\", sourcesURIs);`to autocomplete source fields.\r\n\r\n    @GET\r\n    @Produces(MediaType.TEXT_HTML)\r\n    public Response getIndexPage(@QueryParam(\"project\") URI projectId) throws ObjectStreamException {\r\n        // Retrieve the current project and its sources.\r\n        Project proj = this.getProject(projectId);\r\n        LinkedList<String> sourcesURIs = getSourcesURIs(proj.getSources());\r\n        // Retrieve Datalift's internal repository.\r\n        Repository internal = Configuration.getDefault().getInternalRepository();\r\n        RepositoryConnection internalco = internal.newConnection();\r\n        \r\n        HashMap<String, Object> args = new HashMap<String, Object>();\r\n        args.put(\"it\", proj);\r\n        args.put(\"sources\", sourcesURIs);\r\n        args.put(\"classes\", getAllClasses(internalco, sourcesURIs));\r\n        args.put(\"predicates\", getAllPredicates(internalco, sourcesURIs));\r\n        \r\n        return Response.ok(this.newViewable(\"/interface.vm\", args)).build();\r\n    }"}