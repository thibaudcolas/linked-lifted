{"name":"Linked-lifted","google":"","body":"# Module development for Datalift\r\n\r\n## Datalift architecture\r\n\r\nThe [Datalift](\"http://datalift.org/\") publishing platform is developed on a large technology stack.\r\nServer-side :\r\n\r\n_TODO_\r\n\r\nClient-side :\r\n\r\n_TODO_\r\n\r\n\r\n## Overview of the development workflow\r\n\r\nDatalift can be deployed in two ways :\r\n\r\n* During development, inside an application server like Tomcat.\r\n* In a production environment, as a native stand-alone application.\r\n\r\nHere we'll look at how to automate our development workflow divided into three steps : \r\n\r\n1. Module source code compilation.\r\n2. Jar deployment inside the Datalift home.\r\n3. Refreshing our modifications.\r\n\r\n### Compilation with Ant\r\n\r\nDatalift and its modules must be compiled using the [Ant](\"https://ant.apache.org/\" \"Ant build tool\") Java building tool. The Datalift architecture and each of its modules have their own Ant build file which will create one JAR per module according to its own rules.\r\nFor a given module, the command to compile its sources and retrieve its JAR is `ant dist` : call to the dist target of our build.xml file.\r\n\r\nWe can call it from our own script using :\r\n\r\n    <target name=\"compile\">\r\n        <subant target=\"dist\">\r\n            <filelist dir=\"${project.code}\" files=\"${module.name}\"/>\r\n        </subant>\r\n    </target>\r\n\r\n### Deployment within Tomcat\r\n\r\nOnce the JAR is created, it must be placed inside the \"modules\" directory of the Datalift installation directory. In a development environment, its path is `../datalift-home/modules`.\r\nIt is unneccesary to redeploy the WAR nor the whole datalift-home at every modification to our module.\r\n\r\n    <target name=\"deploy\" depends=\"compile, transfer\"/>\r\n\r\n\r\n    <target name=\"transfer\">\r\n        <copy file=\"${module.jar}\" todir=\"${project.modules}\" overwrite=\"true\"/>\r\n    </target>\r\n\r\n__/!\\\\__ If our modifications only affect static HTML code, the JAR transfer will suffice to update our HTML rendering. Otherwise, we'll also have to reload Tomcat.\r\n\r\n    <target name=\"reload\" depends=\"stop, deploy, start\"/>\r\n\r\n    <target name=\"stop\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <arg line=\"stop\"/>\r\n        </java>\r\n        <waitfor maxwait=\"3000\" checkevery=\"1000\">\r\n            <not>\r\n                <socket server=\"${tomcat.server}\" port=\"${tomcat.port}\"/>\r\n            </not>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.stop}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.stop}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nWe wait for Tomcat not to answer anymore to judge it stopped. We use `say` and `growlnotify` to make our lives easier.\r\n\r\n    <target name=\"start\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <jvmarg value=\"-Ddatalift.home=${project.home}\"/>\r\n        </java>\r\n        <waitfor maxwait=\"10000\" checkevery=\"1000\">\r\n            <http url=\"${module.url}\"/>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.start}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.start}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nThe `datalift.home` argument is used to target the datalift-home directory where our modules and configuration files are. We wait for our module's URL to be retrieved to let the start process pass.\r\n\r\n### Results refreshing\r\n\r\nTo maximize automation, we don't want to have to manually refresh our HTML rendering. In order to do so, we can use the `ant open` command which will automatically open the module URL into our default browser. With this method we'll still have to go to the command line.\r\n\r\n    <target name=\"open\">\r\n        <exec executable=\"open\" spawn=\"yes\">\r\n            <arg line=\"${module.url}\"/>\r\n        </exec>\r\n    </target>\r\n\r\nTo not have to use the command line, we use [LiveReload](\"http://livereload.com/\"). LiveReload monitors our module's source code and automatically triggers browser refresh each time a modification is detected. LiveReload also allows to preceed each refresh by a script execution, thus we're going to use it to fully automate our workflow :\r\n \r\n* At any modification inside the `web` directory, LiveReload will execute `ant -buildfile live-build.xml deploy`, which will update the JAR file.\r\n* At any modification inside the `java` directory, which requires Tomcat to be reloaded, we'll launch `ant -buildfile ../../live-build.xml reload`.\r\n\r\nAll that's left to do is tell LiveReload to focus on .vm, .java and .properties files and the update process will be triggered at each file save.\r\n\r\nOur development cycle can be further optimized by hosting our .css and .js files outside of our module : they'll be hosted on another local HTTP server : they are stored in /modulepath/src/web/public and made available with `open http://localhost:8000 && python -m SimpleHTTPServer`. LiveReload can be told to monitor the public folder and to automatically refresh the browser, without needing to redeploy our JAR.\r\n\r\n## StringToURI integration\r\n\r\nAs a linked data publishing platform, Datalift needs dataset interconnection modules.","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"New user interfaces for interconnection modules"}