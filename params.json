{"body":"# Module development for Datalift\r\n\r\n- [Fast-paced build script as a Gist](https://gist.github.com/2989006)\r\n- [UI inspiration stack on Delicious](https://delicious.com/stacks/view/EqgnIa)\r\n\r\n## Datalift architecture\r\n\r\nThe [Datalift](http://datalift.org/) publishing platform is developed on a large technology stack.\r\n\r\n__Server-side :__\r\n\r\n- JEE 5\r\n- Jersey 1.9\r\n- Shiro 1.1.0\r\n- Velocity 1.7\r\n- Sesame 2.6\r\n- Empire 0.7\r\n- Log4j 1.2.16\r\n- OpenCSV 2.3\r\n- Wro4j 1.4.1\r\n\r\n__Client-side :__\r\n\r\n- Velocity 1.7\r\n- HTML\r\n- CSS\r\n- Javascript\r\n- jQuery 1.5.2\r\n- jQuery UI 1.8.9\r\n- jQuery grid 4.0.0\r\n\r\nThe Velocity Engine uses the Velocity Template Language (VTL), but web pages can also be made entirely out of static HTML.\r\n\r\n## Overview of the development workflow\r\n\r\nDatalift can be deployed in two ways :\r\n\r\n* During development, inside an application server like Tomcat.\r\n* In a production environment, as a native stand-alone application.\r\n\r\nHere we'll look at how to automate our development workflow divided into three steps : \r\n\r\n1. Module source code compilation.\r\n2. Jar deployment inside the Datalift home.\r\n3. Refreshing our modifications.\r\n\r\n### Compilation with Ant\r\n\r\nDatalift and its modules must be compiled using the [Ant](https://ant.apache.org/) Java building tool. The Datalift architecture and each of its modules have their own Ant build file which will create one JAR per module according to its own rules.\r\nFor a given module, the command to compile its sources and retrieve its JAR is `ant dist` : call to the dist target of our build.xml file.\r\n\r\nWe can call it from our own script using :\r\n\r\n    <target name=\"compile\">\r\n        <subant target=\"dist\">\r\n            <filelist dir=\"${project.code}\" files=\"${module.name}\"/>\r\n        </subant>\r\n    </target>\r\n\r\n### Deployment within Tomcat\r\n\r\nOnce the JAR is created, it must be placed inside the \"modules\" directory of the Datalift installation directory. In a development environment, its path is `../datalift-home/modules`.\r\nIt is unneccesary to redeploy the WAR nor the whole datalift-home at every modification to our module.\r\n\r\n    <target name=\"deploy\" depends=\"compile, transfer\"/>\r\n\r\n\r\n    <target name=\"transfer\">\r\n        <copy file=\"${module.jar}\" todir=\"${project.modules}\" overwrite=\"true\"/>\r\n    </target>\r\n\r\n__/!\\\\__ If our modifications only affect static HTML code, the JAR transfer will suffice to update our HTML rendering. Otherwise, we'll also have to reload Tomcat.\r\n\r\n    <target name=\"reload\" depends=\"stop, deploy, start\"/>\r\n\r\n    <target name=\"stop\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <arg line=\"stop\"/>\r\n        </java>\r\n        <waitfor maxwait=\"3000\" checkevery=\"1000\">\r\n            <not>\r\n                <socket server=\"${tomcat.server}\" port=\"${tomcat.port}\"/>\r\n            </not>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.stop}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.stop}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nWe wait for Tomcat not to answer anymore to judge it stopped. We use `say` and `growlnotify` to make our lives easier.\r\n\r\n    <target name=\"start\">\r\n        <java jar=\"${tomcat.bootstrap}\" fork=\"true\" spawn=\"true\">\r\n            <jvmarg value=\"-Dcatalina.home=${tomcat.home}\"/>\r\n            <jvmarg value=\"-Ddatalift.home=${project.home}\"/>\r\n        </java>\r\n        <waitfor maxwait=\"10000\" checkevery=\"1000\">\r\n            <http url=\"${module.url}\"/>\r\n        </waitfor>\r\n        <exec executable=\"say\" spawn=\"yes\">\r\n\t    <arg line=\"${tomcat.msg.start}\"/>\r\n\t</exec>\r\n\t<exec executable=\"growlnotify\" spawn=\"yes\">\r\n\t    <arg line=\"growlnotify -a 'Tomcat Controller' -m '${tomcat.msg.start}'\"/>\r\n\t</exec>\r\n    </target>\r\n\r\nThe `datalift.home` argument is used to target the datalift-home directory where our modules and configuration files are. We wait for our module's URL to be retrieved to let the start process pass.\r\n\r\n### Results refreshing\r\n\r\nTo maximize automation, we don't want to have to manually refresh our HTML rendering. In order to do so, we can use the `ant open` command which will automatically open the module URL into our default browser. With this method we'll still have to go to the command line.\r\n\r\n    <target name=\"open\">\r\n        <exec executable=\"open\" spawn=\"yes\">\r\n            <arg line=\"${module.url}\"/>\r\n        </exec>\r\n    </target>\r\n\r\nTo not have to use the command line, we use [LiveReload](http://livereload.com/). LiveReload monitors our module's source code and automatically triggers browser refresh each time a modification is detected. LiveReload also allows to preceed each refresh by a script execution, thus we're going to use it to fully automate our workflow :\r\n \r\n* At any modification inside the `web` directory, LiveReload will execute `ant -buildfile live-build.xml deploy`, which will update the JAR file.\r\n* At any modification inside the `java` directory, which requires Tomcat to be reloaded, we'll launch `ant -buildfile ../../live-build.xml reload`.\r\n\r\nAll that's left to do is tell LiveReload to focus on .vm, .java and .properties files and the update process will be triggered at each file save.\r\n\r\nOur development cycle can be further optimized by hosting our .css and .js files outside of our module : they'll be hosted on another local HTTP server : they are stored in /modulepath/src/web/public and made available with `open http://localhost:8000 && python -m SimpleHTTPServer`. LiveReload can be told to monitor the public folder and to automatically refresh the browser, without needing to redeploy our JAR.\r\n\r\n## StringToURI integration\r\n\r\nAs a linked data publishing platform, Datalift needs dataset interconnection modules. [StringToURI](http://stringtouri.assembla.me) is a little tool which replaces strings inside a dataset by URIs to another dataset's entities according to different criteria. It'll be integrated into Datalift as a starter project to be done before bigger module interface developments.\r\n\r\n### Interface\r\n\r\nHere's our final mockup :\r\n\r\n![Mockup of the StringToURI module interface](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/mockup.png)\r\n\r\nWe use a simple two columns layout. While it makes the path to completion harder to understand, it makes it easier to distinguish between the two groups of inputs : one for the dataset we're working on, and one for the one we'll link to.\r\nEach field is surrounded by a label and a much longer description, where the field maybe mentionned as required. Fields' placeholders also tell whether the fields are required, and color code helps distinction between correct values and errors / empty fields. The textfield's width depends on the window's width with a breakpoint at 350px, which is the minimum width.\r\n\r\nHere's the final result :\r\n\r\n![The final StringToURI module interface](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/parameters.png)\r\n\r\n![Success and error states](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/states.png)\r\n\r\nThe two groups are much more separated (using fieldsets), a cancel button has ben added as a [secondary action](http://www.lukew.com/ff/entry.asp?571), and all select inputs have been replaced with text fields with autocompletion to allow faster input and copy and paste.\r\n\r\nWhile this result may not be as eye candy as the mockup, it makes use of the Datalift default theme while introducing new elements such as top-label inputs. ([Here is why.](http://www.lukew.com/ff/entry.asp?504))\r\n\r\nNon-default Datalift CSS :\r\n\r\n        .form-stack {\r\n\t\tdisplay:block;\r\n\t\tmargin:10px 0 0;\r\n\t\tpadding:10px;\r\n\t}\r\n\r\n\t.form-stack label {\r\n\t\tfont-weight:bold;\t\r\n\t\tmargin-bottom:3px;\r\n\t\tdisplay:block;\r\n\t}\r\n\r\n\t.form-stack input[type=text] {\r\n\t\twidth:350px;\r\n\t}\r\n\r\n\t.form-stack p {\r\n\t\tmargin:2px 0;\r\n\t\tcolor:#666;\r\n\t\tfont-size:75%;\r\n\t}\r\n\r\n\t.form-stack .ui-icon {\r\n\t\tfloat:left;\r\n\t\tmargin-right: 5px;\r\n\t\tdisplay:none;\r\n\t}\r\n\r\nEverything is built to keep the overall Datalift look and feel while improving usability, accessibility (visual cues with colors and icons, textual cues as well) and completion time. We want to keep using the default CSS and jQuery UI theme as much as possible. We want our layout to adapt itself to the available screen real estate :\r\n\r\n![A small screen size](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/small.png)\r\n\r\n![A view for larger screens](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/large.png)\r\n\r\nRegarding behavior, our module makes use of jQuery and of its multiple capabilities. We use it to change the look of our fields according to their state of completion :\r\n\r\n\tfunction errorState(field) {\r\n\t\tfield.removeClass(\"ui-state-success\");\r\n\t\tfield.parent().addClass(\"ui-state-error\");\r\n\t\tfield.next(\"p\").contents().first()\r\n\t\t\t.removeClass(\"ui-icon-help ui-icon-check\")\r\n\t\t\t.addClass(\"ui-icon-alert\")\r\n\t\t\t.show();\r\n\t}\r\n\r\nWe also use its autocompletion widget and its event handler API : \r\n\r\n\tourpredicate.autocomplete({source: ourpredicates, minLength: 0, delay: 300});\r\n\tourpredicate.blur(function() {validateMandatory(ourpredicate, ourpredicates);});\r\n\ttheirpredicate.autocomplete({source: theirpredicates, minLength: 0, delay: 300});\r\n\ttheirpredicate.blur(function() {validateMandatory(theirpredicate, theirpredicates);});\r\n\t\r\n\t$(\"#linkage-form\").submit(function(){return validateAll();});\r\n\r\nThe web page's HTML / structure is made with [Velocity](https://velocity.apache.org/), which syntaxe looks like this :\r\n\r\n\t<h3 class=\"ui-widget-header dl-widget-header\">\r\n\t\t#if ($current == $english) \r\n\t\t\t${it.title} #i18n('project.label') \r\n\t\t#else \r\n\t\t\t#i18n('project.label') ${it.title} \r\n\t\t#end \r\n\t\t&mdash; #i18n('stringtouri.title')\r\n\t</h3>\r\n\r\nHere we use it to display our title in a different order whether the current language is english or french. `#i18n`manages content internationalization while ${var} is used to access variables defined inside our Java code.\r\n\r\nHere is an english version :\r\n\r\n![StringToURI's interface in english](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/english.png)\r\n\r\nVelocity can manage complex object types like lists : \r\n\r\n\tvar datasets = [\r\n\t\t#foreach( $source in $sources )\r\n\t\t\"$source\",\r\n\t\t#end\r\n\t];\r\n\r\nStringToURI has two other views which are served after the interconnection process. The results view makes use of Datalift's conventions to display the newly created links in a searchable / sortable array.\r\n\r\n![New links are displayed in an array](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/results.png)\r\n\r\nVelocity can handle complex data types like lists of lists :\r\n\r\n\t## For each new triple, we'll display its S, P, O.\r\n\t#foreach( $triple in $newtriples )\r\n\t\t#if( $foreach.count > $maxEntries ) \r\n\t\t\t#break \r\n\t\t#end\r\n\t\t## Line number may be useful.\r\n\t\t<tr><td>$velocityCount</td>\r\n\t  \t#foreach( $elt in $triple ) \r\n\t  \t\t<td title=\"$!esc.html($elt)\">$!esc.html($elt)</td> \r\n\t  \t#end\r\n\t\t</tr>\r\n\t#end\r\n\r\nThe other view displays errors, if any. As parameters are checked in Javascript, it may not seem important to check them again on the server-side, but indeed it is if Javascript isn't allowed or if StringToURI is launched from a remote module (via GET parameters). \r\n\r\n![Errors in the parameters](https://github.com/ThibWeb/linked-lifted/raw/gh-pages/errors.png)\r\n\r\n### Back-end\r\n\r\nTo serve our interfaces with their Velocity template language, we have to manage them with Java classes.\r\nWe use Jax-RS / [Jersey](http://jersey.java.net/) annotations to indicate our web architecture to the Datalift Core : \r\n\r\n\t@Path(StringToURI.MODULE_NAME)\r\n\tpublic class InterconnectionController extends BaseModule implements ProjectModule {\r\n\t...\r\n\t}\r\n\r\nWe must indicate which kind of project our module can handle to our ProjectManager :\r\n\r\n    public UriDesc canHandle(Project p) {\r\n        // The project can be handled if it has at least two RDF sources.\r\n        if (hasMultipleRDFSources(p.getSources(), 2)) {\r\n            // Here the URL and label to our object in ProjectManager\r\n            UriDesc uridesc = new UriDesc(this.getName() + \"?project=\" + p.getUri(),this.label);\r\n        }       \r\n        return uridesc;\r\n    }\r\n\r\nWe then use annotations to indicate what to serve when asking for the module's index page : Here, we are using GET, producing HTML and one of the query parameters is our current project's URI.  \r\nWe access Datalift's internal repository to make its data available to our Velocity template by using the `args` HashMap : `args.put(\"sources\", sourcesURIs);`to autocomplete source fields.\r\n\r\n    @GET\r\n    @Produces(MediaType.TEXT_HTML)\r\n    public Response getIndexPage(@QueryParam(\"project\") URI projectId) throws ObjectStreamException {\r\n        // Retrieve the current project and its sources.\r\n        Project proj = this.getProject(projectId);\r\n        LinkedList<String> sourcesURIs = model.getSourcesURIs(proj);\r\n        \r\n        HashMap<String, Object> args = new HashMap<String, Object>();\r\n        \r\n        args.put(\"sources\", sourcesURIs);\r\n        args.put(\"classes\", model.getAllClasses(sourcesURIs));\r\n        args.put(\"predicates\", model.getAllPredicates(sourcesURIs));\r\n        \r\n        return Response.ok(this.newViewable(\"/stringtouri-form.vm\", args)).build();\r\n    }\r\n\r\nTwo other methods are used to handle the execution :\r\n\r\n    @POST\r\n    @Produces(MediaType.TEXT_HTML)\r\n    public Response doSubmit(...) { ... }\r\n\r\n    @GET\r\n    @Path(\"go\")\r\n    @Produces(MediaType.TEXT_HTML)\r\n    public Response doRemoteSubmit(...) { return doSubmit(...); }\r\n\r\nThey both end up delegating the launch and parameters validation to our application's model. It's the model which manages queries to the repositories and back-end logic, like logging important events such as the StringToURI process launch :\r\n\r\n\tif (validateAll(...)) {\r\n\t\t// Launches a new StringToURI process.\r\n        SesameApp stu = new SesameApp(INTERNAL_URL, INTERNAL_URL, sourceContext, targetContext);\r\n       \r\n        if (sourceClass.isEmpty() || targetClass.isEmpty()) {\r\n        \tstu.useSimpleLinkage(sourcePredicate, targetPredicate);\r\n        }\r\n        else {\r\n        \tstu.useTypedLinkage(sourcePredicate, targetPredicate, sourceClass, targetClass);\r\n        }\r\n        \r\n        stu.useSPARQLOutput(false);\r\n        ret = stu.getOutputAsList();\r\n        \r\n        if (LOG.isInfoEnabled()) {\r\n        \tLOG.info(MODULE_NAME + \" interconnection OK.\");\r\n        }\r\n\r\nOr such as queries sent to the repository :\r\n\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(MODULE_NAME + \" \" + query);\r\n    }\r\n    \r\n    try {\r\n        tq = internal.prepareTupleQuery(QueryLanguage.SPARQL, query);\r\n        tqr = tq.evaluate();\r\n        \r\n        if (!hasCorrectBindingNames(tqr, bind)) {\r\n            throw new MalformedQueryException(\"Wrong query bindings - \" + query);\r\n        }\r\n        \r\n        while (tqr.hasNext()) {\r\n            ret.add(tqr.next().getValue(bind).stringValue());\r\n        }\r\n    }\r\n\r\n### StringToURI's next improvements\r\n\r\nIn the near future, it would be nice to revamp the StringToURI's interface to be even more responsive to different screen sizes while keeping it simple and error-proof. \r\n \r\nHere are some interesting features to develop :\r\n\r\n* Better design to maximize screen efficiency.\r\n* AJAX calls to refresh autocomplete values while typing.\r\n* AJAX calls to validate user input, thus keeping all of the validation logic on the server side.\r\n* New intermediate state which allows to visualize new triples before validating the update.\r\n* New ways to call the process from other modules / to pre-fill the form.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Linked-lifted","tagline":"New user interfaces for interconnection modules"}